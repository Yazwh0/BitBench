library BitBench.Switcher.Manager;

import Init="initialisation.bmasm";

private static void Setup()
{
    .segment bench_general
    .scope bitbench_switcher
    .padvar byte current_process
    .padvar byte next_process
    .padvar short return_address
    .endscope
    .endsegment
}

private static void Proc()
{
    // Stack for every process must be stored as
    // Return address if interrupted\self halted or start address if not started yet.
    // CPU Flags
    // A
    // Y
    // X
    // Ram Bank
    // Rom Bank

    .scope bitbench_switcher
    
    .proc initialise

        lda #$ff                ; set to nothing running. we use 0 to sit in a spin loop if nothing is scheduled
        sta current_process

        rts

    .endproc

    // activate a process and resume it from within in an interrupt
    // works slightly differently to when called by a process handing back control. probably.
    // if the current process is already tagged as running, then we assume nothing is to be done.
    // Inputs:
    // A: Process ID
    .proc activate_process_interrupt

        cmp current_process
        bne not_already_active
        rts

    .not_already_active:
        sta next_process    ; store current process for later

        ; adjust stack so it can be rti'd
        ; this proc must be called from the IRQ handler, with only this proc jsr'd
        pla
        sta return_address
        pla
        sta return_address + 1

        ; get pointer addresses for current process
        lda current_process     
        cmp #$ff                                    ; startup
        beq no_current_process   
        SetZpPointersRamBankToCurrentProcess();        // stamps A and X

        ; bench_general:zp_pointer now points to stack,
        ; bench_general:zp_pointer2 points to data

        ; backup stack
        tsx
        txa
        ldy #$ff
        sta (bench_general:zp_pointer), y           ; store stack pointer at the end of the stack
        tay
    .loop:
        lda $100, x
        sta (bench_general:zp_pointer), y
        inx
        iny
        cpy #$ff
        bne -loop                                   ; we dont want to write when y = $ff

        ; backup data
        ldy bench_general:application_zp_count
        beq +data_copy_done
        lda #$22
        sta bench_general:zp_pointer2
        dey
    .loop:
        lda $00, y
        sta (bench_general:zp_pointer2), y
        bne -loop
    .data_copy_done:

    .no_current_process:
        ; copy new process stack
        lda next_process
        sta current_process
        SetZpPointersRamBankToCurrentProcess();        // stamps A and X
        
        ldy #$ff
        lda (bench_general:zp_pointer), y               ; get stack pointer        
        tay
        tax
        txs                                             ; set pointer
        inx
        iny
    .loop:
        lda (bench_general:zp_pointer), y
        sta $100, x
        inx
        iny
        bne -loop

        ; copy new process ZP Data
        lda #$22
        sta bench_general:zp_pointer2
        lda #0
    .loop:
        dey
        beq +data_copy_done
        lda (bench_general:zp_pointer2), Y
        sta $00, Y
        jmp -loop
    .data_copy_done:

        lda #1
        sta RAM_BANK

        ; restore this jsr
        ; todo: this coul be a jmp??
        lda return_address + 1
        pha
        lda return_address
        pha
        
    .all_done:
        rts

    .endproc

    ; stacks are always stored ready to rti
    .proc store_stack
        rts
    .endproc

    .proc restore_stack
        rts
    .endproc

    // store the data for a process so we can switch

    .proc pause_process

        lda #$ff                ; set to nothing running???
        sta current_process

        rts

    .endproc
    
    .endscope
}

// Assumes A has the current_process, destroys A and X
public static void SetZpPointersRamBankToCurrentProcess()
{
    clc
    rol 
    rol     ; * 4
    tax
    lda bitbench_process:process_data + bitbench_process:StackBlock, x
    sta bench_general:zp_pointer + 1
    stz bench_general:zp_pointer

    lda bitbench_process:process_data + bitbench_process:DataBlock, x
    sta bench_general:zp_pointer2 + 1
    stz bench_general:zp_pointer2

    lda bitbench_process:process_data + bitbench_process:PrimaryBank, x
    sta RAM_BANK                            ; fetch primary bank and switch
}

public override void Initialise()
{
    Init.Add(Proc);
    Setup();
}
