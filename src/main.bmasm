import BM="bench\BM.bmasm";
import Global="bench\globals.bmasm";
import Init="bench\initialisation.bmasm";
import Process="bench\process.bmasm";
import Memory="bench\memory.bmasm";
import ApiHelper="bench\apihelper.bmasm";
import Switcher="bench\switcher.bmasm";
import Scheduler="bench\scheduler.bmasm";
import Window="bench\window.bmasm";

.machine CommanderX16R42
    BM.X16Header();

    .scope bench_main

    ; initialise the system
    sei
    
    ; reset the stack, we never return
    ldx #$ff
    txs
    phx ; add a empty entry for the stack pointer

    jsr initialise

;     lda #$3
;     sta bench_window:window_top
;     lda #$27
;     sta bench_window:window_left
;     lda #$10
;     sta bench_window:window_width
;     lda #$30
;     sta bench_window:window_height
;     lda #<title3
;     sta bench_window:window_title
;     lda #>title3
;     sta bench_window:window_title + 1

;     jmp +skip
;  .title3:
//      BM.IsoPetscii("STATUS");
;  .skip:

;     lda #01
;     jsr bench_window:create_window
;     sec
;     jsr bench_window:draw_window

    lda #11
    ldx #<filename
    ldy #>filename
    jsr bench_process:load

    lda #12
    ldx #<filename2
    ldy #>filename2
    jsr bench_process:load

    cli

.loop: 
    jmp loop



    .proc initialise     

        cld

        lda #1          ; Bench uses bank 1.
        sta RAM_BANK 

        sta IEN         ; vsync interrupt only
        stz CTRL

        jsr bench_window:initialise
        jsr bench_memory:initialise
        jsr bench_scheduler:initialise
        jsr bench_process:initialise
        jsr bench_switcher:initialise

        jsr override_irq

        rts

    .endproc

    .proc override_irq

        // we need to override the whole handler, 
        // so we use the vector at $fffe instead of $314
        // this is because the routine at $314 isn't the whole interrupt handler.

        stz ROM_BANK

        lda $fffe
        sta bench_general:zp_pointer
        lda $ffff
        sta bench_general:zp_pointer + 1

        ; replace default handler with a jump to our own.
        lda #$4c        ; jmp
        sta (bench_general:zp_pointer)
        ldy #1
        lda #<irq
        sta (bench_general:zp_pointer), y
        iny
        lda #>irq
        sta (bench_general:zp_pointer), y

        rts

    .endproc

    .proc irq

        ; add extra data to the stack, prior to storage
        pha
        phy
        phx

        lda #$d
        sta DC_BORDER

        ; check if its a brk
        tsx
        lda $106, x     ; +3 for stack pointer, plus three above 
        and #$10
        bne brk_hit

        ; clear interrupt flag
        lda #01
        sta ISR

        lda RAM_BANK
        pha
        lda ROM_BANK
        pha

        ; call kernel routies
        stz ROM_BANK
        jsr mouse_scan
        jsr joystick_scan
        jsr SCNKEY
        ; clock_update isn't exposed so cannot call 

        lda #05
        sta DC_BORDER

        ; fetch and store mouse movement
        lda bench_general:mouse_buttons
        sta bench_general:prev_mouse_buttons
        
        lda bench_general:mouse_x
        sta bench_general:prev_mouse_x
        lda bench_general:mouse_y
        sta bench_general:prev_mouse_y

        ldx #bench_general:mouse_x
        jsr mouse_get
        sta bench_general:mouse_buttons

        ; convert mouse pixel pos to tile pos, div 8
        clc
        lda bench_general:mouse_x
        ror bench_general:mouse_x + 1
        ror 
        clc
        ror bench_general:mouse_x + 1
        ror
        clc
        ror bench_general:mouse_x + 1
        ror
        sta bench_general:mouse_x

        clc
        lda bench_general:mouse_y
        ror bench_general:mouse_y + 1
        ror
        clc
        ror bench_general:mouse_y + 1
        ror
        clc
        ror bench_general:mouse_y + 1
        ror
        sta bench_general:mouse_y

        jsr GETIN
        sta bench_general:keyboard ; todo, if non-zero, send message to active window, like mouse moves

        ; handle mouse movement
        Global.Call_HandleMouse();

        lda #01
        sta DC_BORDER

        ; check if we need to switch process
        lda #bench_general:bank_bench  ; Bench uses bank 1.
        sta RAM_BANK 

        jsr bench_scheduler:reset    ; reset scheduler for the frame
        jsr bench_scheduler:get_next_process ; returns 0 if nothing to do

        beq nothing_to_do               

        jsr bench_switcher:activate_process_interrupt 

        ; stack here will always have these values even if switched
        pla 
        sta ROM_BANK
        pla
        sta RAM_BANK

        stz DC_BORDER

        plx
        ply
        pla

        rti

        ; todo: handle brk
    .brk_hit:
        stp
        jmp brk_hit    

    .nothing_to_do:
        jsr bench_switcher:store_process
        ; set the return value to the idle loop sprocs
        ; empty the stack, and push a dummy entry
        ldx #$fe
        txs

        lda #>idle_loop
        pha
        lda #<idle_loop
        pha
        lda #0
        pha     ; cpu flags

        stz DC_BORDER

        rti        
    .endproc

    .proc idle_loop

    .loop:
        wai
        jmp loop

    .endproc

    .filename:
    BM.Bytes("TESTAPP.BIN");
    .filename2:
    BM.Bytes("TESTAPP2.BIN");

    .segment bench_general
    .scope bench_main
    .padvar byte irq_hander_l
    .padvar byte irq_hander_h
    .endscope
    .endsegment

    .segment testapp $a000 $2000 TESTAPP.BIN testapp
    ApiHelper.Header("TEST", "entry", "exit", "focus", "blur", 1, 1);

    .entry:    
        lda #$05
        sta bench_window:window_top
        sta bench_window:window_left
        lda #$30
        sta bench_window:window_width
        lda #$10
        sta bench_window:window_height
        lda #<title
        sta bench_window:window_title
        lda #>title
        sta bench_window:window_title + 1

        jmp +skip
    .title:
        BM.IsoPetscii("PROCESS 1");
    .skip:

        lda bench_general:application_processid
        jsr bench_window:create_window
        ;clc
        ;jsr bench_window:draw_window

    .loop:
        jsr test_proc
        inc $02
        jmp -loop

    .proc test_proc
        wai
        rts
    .endproc

    .exit:
        rts

    .focus:
        rts

    .blur:
        rts

    .endsegment

    .segment testapp2 $a000 $2000 TESTAPP2.BIN testapp2
    ApiHelper.Header("TEST2", "entry", "exit", "focus", "blur", 1, 1);

    .byte 1, 2, 3, 4, 5
    .entry:

        lda #$10
        sta bench_window:window_top
        sta bench_window:window_left
        lda #$3c
        sta bench_window:window_width
        lda #$20
        sta bench_window:window_height
        lda #<title2
        sta bench_window:window_title
        lda #>title2
        sta bench_window:window_title + 1

        jmp +skip
    .title2:
        BM.IsoPetscii("PROCESS 2");
    .skip:

        lda bench_general:application_processid
        jsr bench_window:create_window
        ;sec
        ;jsr bench_window:draw_window

        nop
        stz $03
    .loop:
        jsr test_proc
        inc $03
        jmp loop

    .proc test_proc
        wai
        rts
    .endproc

    .exit:
        rts

    .focus:
        rts

    .blur:
        rts

    .endsegment

    ; create procs
    Init.Setup();
